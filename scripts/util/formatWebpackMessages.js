/**
 * Notice:
 *
 * The content of this file and the strategies used here have been heavily inspired by an
 * equivalent functionality of create-react-app, which can be found here:
 * https://github.com/facebookincubator/create-react-app/blob/9b23be825a4f2ef1f3b5e9d7a2b5dcec49d38af2/packages/react-dev-utils/formatWebpackMessages.js
 *
 * They have been adopted to our particular requirements.
 *
 */

const formatUtil = require("./formatUtil");

const friendlySyntaxErrorLabel = "Syntax error:";

/**
 * Regularly, a split message (here: `lines`) no empty string preceding the error
 * message,  which should start at `lines[1]`. However, there are some cases where
 * this does not hold true, thus, it has to be stripped of manually.
 *
 * @param lines The lines to (potentially) clean up.
 * @return The resulting lines.
 */
function removeExtraNewLine(lines) {
  if (lines.length > 2 && lines[1] === "") {
    lines.splice(1, 1);
  }
  return lines;
}

/**
 * Clears out webpack-specific loader notations from a filename.
 * E.g.:
 * Before:
 * ./~/css-loader!./~/postcss-loader!./src/App.css
 * After:
 * /src/App.css
 *
 * @param lines The lines to clean up.
 * @return The cleaned lines.
 */
function removeLoaderNotations(lines) {
  const lastIndexOfExclamationMark = lines[0].lastIndexOf("!");

  if (lastIndexOfExclamationMark !== -1) {
    lines[0] = lines[0].substr(lastIndexOfExclamationMark + 1);
  }
  return lines;
}

/**
 * Webpack adds a list of entry points to warning messages:
 *  @ ./src/index.js
 *  @ multi react-scripts/~/react-dev-utils/webpackHotDevClient.js ...
 *
 * In almost every case, this does not provide any additional useful information,
 * thus, it may be removed safely.
 *
 * @param lines The lines to clear up.
 * @return The filtered list of lines.
 */
function removeEntryPointAnnotations(lines) {
  return lines.filter(line => line.indexOf(" @ ") !== 0);
}

/**
 * "Module not found" messages can be quite verbose, since they add information about
 * unresolved files or directories, or path sensitivity problems (in our case). This gets
 * added to the information that the module could not be found.
 * This additional information is not helpful in most cases since it's more like a duplicate,
 * and thus may be removed safely.
 *
 * @param lines The lines to optimize.
 * @return The optimized lines.
 */
function shrinkModuleNotFoundErrors(lines) {
  if (lines[1].indexOf("Module not found: ") === 0) {
    lines = [
      lines[0],
      lines[1]
        .replace("Cannot resolve 'file' or 'directory' ", "")
        .replace("Cannot resolve module ", "")
        .replace("Error: ", "")
        .replace("[CaseSensitivePathsPlugin] ", "") // Special plugin message.
    ];
  }
  return lines;
}

/**
 * Optimizes messages related to a module build failure caused by a syntax error.
 *  Before:
 * "Module build failed: SyntaxError:"
 * After:
 *  "Syntax error:"
 *
 * @param lines The lines to optimize.
 * @return The optimized lines.
 */
function optimizeSyntaxErrorMessages(lines) {
  if (lines[1].indexOf("Module build failed: ") === 0) {
    lines[1] = lines[1].replace(
      "Module build failed: SyntaxError:",
      friendlySyntaxErrorLabel
    );
  }
  return lines;
}

/**
 * Optimizes export error messages to be more readable.
 *
 * @param lines The lines to optimize.
 * @return The optimized lines.
 */
function optimizeExportErrorMessages(lines) {
  const exportError = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
  if (lines[1].match(exportError)) {
    lines[1] = lines[1].replace(
      exportError,
      "$1 '$4' does not contain an export named '$3'."
    );
  }
  return lines;
}

/**
 * Internal stacks are generally useless so they can be stripped in most cases,
 * except those that are generated by tools that evaluate the generated bundle.
 * Those are marked with `webpack:`.
 * I.e.: Strip all except those containing the marker.
 *
 * @param message The message to clean up.
 * @return The stripped down message.
 */
function stripInternalStacks(message) {
  message = message.replace(
    /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm,
    ""
  );
  return message;
}

/**
 * Cleans up and beautifies webpack error messages.
 *
 * @param message The message to clean up / beautify.
 * @param firstLineFormatter A special formatter to be applied on the first line of the message.
 * @return The cleaned up message.
 */
function formatMessage(message, firstLineFormatter) {
  let lines = message.split("\n");

  lines = removeExtraNewLine(lines);
  lines = removeLoaderNotations(lines);
  lines = removeEntryPointAnnotations(lines);

  // Regularly, `lines` will be an array with two entries from here on,
  // i.e. the source file path and the error message.
  // If at least one of them is empty, we might stop further cleanup
  // and return their joined version.
  if (!lines[0] || !lines[1]) {
    return lines.join("\n");
  }

  lines = shrinkModuleNotFoundErrors(lines);
  lines = optimizeSyntaxErrorMessages(lines);
  lines = optimizeExportErrorMessages(lines);

  // Beautify file path.
  lines[0] = firstLineFormatter(lines[0]);

  // Reassemble the message.
  message = lines.join("\n");

  message = stripInternalStacks(message);

  return message.trim();
}

function formatWebpackMessages(json) {
  const formattedErrors = json.errors.map(function(message) {
    return formatMessage(message, formatUtil.formatFirstLineMessage);
  });
  const formattedWarnings = json.warnings.map(function(message) {
    return formatMessage(message, formatUtil.formatFirstLineMessage);
  });

  return Object.assign({}, json, {
    errors: formattedErrors,
    warnings: formattedWarnings
  });
}

module.exports = formatWebpackMessages;
module.exports.formatMessage = formatMessage;
